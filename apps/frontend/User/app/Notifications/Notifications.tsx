import React, { useState, useEffect, useMemo } from "react";
import { ScrollView, StatusBar, StyleSheet, View, ActivityIndicator, RefreshControl, Text, ImageBackground } from "react-native";
import { TopBar } from "../../components/scholarship/TopBar";
import { NotificationTabs } from "../../components/notifications/NotificationTabs";
import { NotificationCard, NotificationItem } from "../../components/notifications/NotificationCard";
import { notificationApi, Notification, NotificationType } from "../../services/notification.api";
import { useWebSocket } from "../../contexts/WebSocketContext";
// MainPageÏôÄ ÏùºÏπòÌïòÎèÑÎ°ù ÏàòÏ†ï
import SOLSOLBackground from "../../assets/images/SOLSOLBackground.png";

export default function NotificationsPage() {
  const [activeTab, setActiveTab] = useState<string>("Ï†ÑÏ≤¥");
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  
  // WebSocket Ïª®ÌÖçÏä§Ìä∏ÏóêÏÑú Ïã§ÏãúÍ∞Ñ ÏïåÎ¶º Í∞ÄÏ†∏Ïò§Í∏∞
  const { 
    notifications: realtimeNotifications, 
    unreadCount, 
    isConnected, 
    connectionState, 
    markAsRead: markRealtimeAsRead,
    deleteNotification: deleteRealtimeNotification 
  } = useWebSocket();

  // Î∞±ÏóîÎìú ÏïåÎ¶º Îç∞Ïù¥ÌÑ∞Î•º ÌîÑÎ°†Ìä∏ÏóîÎìú ÌòïÌÉúÎ°ú Î≥ÄÌôò
  const convertToNotificationItem = (notification: Notification): NotificationItem => {
    const formatTimestamp = (createdAt: string) => {
      const now = new Date();
      const created = new Date(createdAt);
      const diffInHours = Math.floor((now.getTime() - created.getTime()) / (1000 * 60 * 60));
      
      if (diffInHours < 1) return "Î∞©Í∏à Ï†Ñ";
      if (diffInHours < 24) return `${diffInHours}ÏãúÍ∞Ñ Ï†Ñ`;
      
      const diffInDays = Math.floor(diffInHours / 24);
      if (diffInDays < 7) return `${diffInDays}Ïùº Ï†Ñ`;
      
      return `${Math.floor(diffInDays / 7)}Ï£ºÏùº Ï†Ñ`;
    };

    const getTypeAndRoute = (type: NotificationType) => {
      switch (type) {
        case NotificationType.NEW_SCHOLARSHIP:
          return { 
            displayType: "scholarship", 
            actionLabel: "Ïû•ÌïôÍ∏à Î≥¥Í∏∞", 
            actionRoute: "/Scholarship/ScholarshipDetail" 
          };
        case NotificationType.SCHOLARSHIP_RESULT:
          return { 
            displayType: "scholarship", 
            actionLabel: "Í≤∞Í≥º ÌôïÏù∏", 
            actionRoute: "/MyScholarship/MyScholarship" 
          };
        case NotificationType.MILEAGE_DEPOSIT:
          return { 
            displayType: "scholarship", 
            actionLabel: "ÎßàÏùºÎ¶¨ÏßÄ ÌôïÏù∏", 
            actionRoute: "/MyPage/MyPage" 
          };
        case NotificationType.ACCOUNT_TRANSFER:
          return { 
            displayType: "scholarship", 
            actionLabel: "Í≥ÑÏ¢å ÌôïÏù∏", 
            actionRoute: "/MyPage/MyPage" 
          };
        case NotificationType.SCHEDULE:
          return { 
            displayType: "schedule", 
            actionLabel: "ÏùºÏ†ï ÌôïÏù∏", 
            actionRoute: "/Schedule/MyCalendar" 
          };
        case NotificationType.DEADLINE_REMINDER:
          return { 
            displayType: "deadline", 
            actionLabel: "Ïû•ÌïôÍ∏à Î≥¥Í∏∞", 
            actionRoute: "/Scholarship/ScholarshipDetail" 
          };
        default:
          return { 
            displayType: "scholarship", 
            actionLabel: "ÌôïÏù∏ÌïòÍ∏∞", 
            actionRoute: "/" 
          };
      }
    };

    const typeInfo = getTypeAndRoute(notification.type);

    return {
      id: notification.id.toString(),
      type: typeInfo.displayType,
      title: notification.title,
      message: notification.message,
      timestamp: formatTimestamp(notification.createdAt),
      isRead: notification.isRead,
      actionLabel: typeInfo.actionLabel,
      actionRoute: notification.actionRoute || typeInfo.actionRoute
    };
  };

  // Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ìï®Ïàò
  const loadNotifications = async () => {
    try {
      setLoading(true);
      const data = await notificationApi.getUserNotifications();
      console.log('üéØ Received notifications data:', data);
      console.log('üéØ Data is array:', Array.isArray(data));
      console.log('üéØ Data length:', data?.length || 0);
      setNotifications(Array.isArray(data) ? data : []);
    } catch (error) {
      console.error('ÏïåÎ¶º Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®:', error);
      setNotifications([]);
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  // ÏÉàÎ°úÍ≥†Ïπ® Ìï®Ïàò
  const handleRefresh = () => {
    setRefreshing(true);
    loadNotifications();
  };

  // ÏïåÎ¶º ÏùΩÏùå Ï≤òÎ¶¨ Ìï®Ïàò (Î™®Îì† ÏïåÎ¶º ÏùΩÏúºÎ©¥ ÏûêÎèô ÏÇ≠Ï†ú)
  const handleMarkAsRead = async (notificationId: string) => {
    try {
      const id = parseInt(notificationId);
      const notification = notifications.find(n => n.id === id);
      
      if (!notification) return;
      
      console.log(`üìñ Starting to mark notification as read and delete: ${id}, type: ${notification.type}`);
      
      // Î™®Îì† ÏïåÎ¶ºÏùÑ ÏùΩÏúºÎ©¥ ÏûêÎèô ÏÇ≠Ï†ú
      console.log(`üóëÔ∏è Auto-deleting notification: ${id}`);
      
      // Î∞±ÏóîÎìúÏóêÏÑú ÏïåÎ¶º ÏÇ≠Ï†ú
      await notificationApi.deleteNotification(id);
      
      // WebSocket Ïª®ÌÖçÏä§Ìä∏ÏóêÏÑúÎèÑ ÏÇ≠Ï†ú
      deleteRealtimeNotification(id);
      
      // Î°úÏª¨ ÏÉÅÌÉúÏóêÏÑú Ï†úÍ±∞
      setNotifications(prev => prev.filter(n => n.id !== id));
      
      console.log(`‚úÖ Auto-deleted notification after reading: ${id}`);
    } catch (error) {
      console.error('ÏïåÎ¶º ÏùΩÏùå Ï≤òÎ¶¨ Ïã§Ìå®:', error);
    }
  };

  // Ïä§ÏôÄÏù¥ÌîÑÎ°ú ÏïåÎ¶º ÏÇ≠Ï†úÌïòÎäî Ìï®Ïàò
  const handleSwipeDelete = async (notificationId: string) => {
    try {
      const id = parseInt(notificationId);
      console.log(`üóëÔ∏è Swiping to delete notification: ${id}`);
      
      // Î∞±ÏóîÎìúÏóêÏÑú ÏïåÎ¶º ÏÇ≠Ï†ú
      await notificationApi.deleteNotification(id);
      
      // WebSocket Ïª®ÌÖçÏä§Ìä∏ÏóêÏÑúÎèÑ ÏÇ≠Ï†ú
      deleteRealtimeNotification(id);
      
      // Î°úÏª¨ ÏÉÅÌÉúÏóêÏÑú Ï†úÍ±∞
      setNotifications(prev => prev.filter(n => n.id !== id));
      
      console.log(`‚úÖ Swipe deleted notification: ${id}`);
    } catch (error) {
      console.error('Ïä§ÏôÄÏù¥ÌîÑ ÏÇ≠Ï†ú Ïã§Ìå®:', error);
    }
  };

  // Ïû•ÌïôÍ∏à Î≥¥Í∏∞Î•º ÏúÑÌïú ÏïåÎ¶º ÏÇ≠Ï†ú Ìï®Ïàò (Ïû•ÌïôÍ∏à Í¥ÄÎ†® ÏïåÎ¶ºÎßå)
  const handleDeleteNotificationForAction = async (notificationId: string, actionRoute: string) => {
    try {
      const id = parseInt(notificationId);
      console.log(`üóëÔ∏è Starting to delete notification for action: ${id}`);
      
      // Ïû•ÌïôÍ∏à Í¥ÄÎ†® ÏïåÎ¶ºÏù∏ Í≤ΩÏö∞ÏóêÎßå ÏÇ≠Ï†ú Ï≤òÎ¶¨
      if (actionRoute.includes('/Scholarship/ScholarshipDetail')) {
        // Î®ºÏ†Ä ÏùΩÏßÄ ÏïäÏùÄ ÏïåÎ¶ºÏù¥Î©¥ ÏùΩÏùå Ï≤òÎ¶¨ (unreadCount Í∞êÏÜå)
        const notification = notifications.find(n => n.id === id);
        if (notification && !notification.isRead) {
          await notificationApi.markAsRead(id);
          markRealtimeAsRead(id);
          console.log(`‚úÖ Marked notification ${id} as read before deletion`);
        }
        
        // Î∞±ÏóîÎìúÏóêÏÑú ÏïåÎ¶º ÏÇ≠Ï†ú
        await notificationApi.deleteNotification(id);
        console.log(`‚úÖ Backend deleteNotification successful for: ${id}`);
        
        // WebSocket Ïª®ÌÖçÏä§Ìä∏ÏóêÏÑúÎèÑ ÏÇ≠Ï†ú Ï≤òÎ¶¨
        deleteRealtimeNotification(id);
        console.log(`‚úÖ WebSocket deleteNotification successful for: ${id}`);
        
        // Î°úÏª¨ ÏÉÅÌÉúÏóêÏÑú Ï†úÍ±∞
        setNotifications(prev => {
          const updated = prev.filter(notification => notification.id !== id);
          console.log(`üìù Local state updated - removed notification ${id}, remaining: ${updated.length}`);
          return updated;
        });
      } else {
        // Îã§Î•∏ ÌÉÄÏûÖÏùò ÏïåÎ¶ºÏùÄ ÏùΩÏùå Ï≤òÎ¶¨Îßå
        await handleMarkAsRead(notificationId);
      }
    } catch (error) {
      console.error('ÏïåÎ¶º ÏÇ≠Ï†ú Ï≤òÎ¶¨ Ïã§Ìå®:', error);
    }
  };

  // ÏùΩÏßÄ ÏïäÏùÄ Î™®Îì† ÏïåÎ¶ºÏùÑ ÏùΩÏùå Ï≤òÎ¶¨ÌïòÎäî Ìï®Ïàò
  const markAllUnreadAsRead = async () => {
    try {
      console.log('üìñ Marking all unread notifications as read on page entry');
      
      // ÌòÑÏû¨ Î°úÎìúÎêú ÏïåÎ¶ºÏóêÏÑú ÏùΩÏßÄ ÏïäÏùÄ Í≤ÉÎì§ Ï∞æÍ∏∞
      const unreadNotifications = notifications.filter(n => !n.isRead);
      console.log(`üìñ Found ${unreadNotifications.length} unread notifications to mark as read`);
      
      // WebSocket Ïã§ÏãúÍ∞Ñ ÏïåÎ¶ºÏóêÏÑú ÏùΩÏßÄ ÏïäÏùÄ Í≤ÉÎì§ÎèÑ Ï∞æÍ∏∞
      const unreadRealtimeNotifications = realtimeNotifications.filter(n => !n.isRead);
      console.log(`üìñ Found ${unreadRealtimeNotifications.length} unread realtime notifications to mark as read`);
      
      // Í∞ÅÍ∞ÅÏùò ÏùΩÏßÄ ÏïäÏùÄ ÏïåÎ¶ºÏùÑ ÏùΩÏùå Ï≤òÎ¶¨ (API ÏïåÎ¶º)
      for (const notification of unreadNotifications) {
        try {
          await notificationApi.markAsRead(notification.id);
          markRealtimeAsRead(notification.id);
          console.log(`‚úÖ Marked notification ${notification.id} as read on page entry`);
        } catch (error) {
          console.warn(`‚ö†Ô∏è Failed to mark notification ${notification.id} as read:`, error);
        }
      }
      
      // WebSocket Ïã§ÏãúÍ∞Ñ ÏïåÎ¶ºÎì§ÎèÑ ÏùΩÏùå Ï≤òÎ¶¨
      for (const notification of unreadRealtimeNotifications) {
        try {
          markRealtimeAsRead(notification.id!);
          console.log(`‚úÖ Marked realtime notification ${notification.id} as read on page entry`);
        } catch (error) {
          console.warn(`‚ö†Ô∏è Failed to mark realtime notification ${notification.id} as read:`, error);
        }
      }
      
      // Î°úÏª¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
      if (unreadNotifications.length > 0 || unreadRealtimeNotifications.length > 0) {
        setNotifications(prev => 
          prev.map(notification => ({ ...notification, isRead: true }))
        );
        
        // ÏùΩÏùå Ï≤òÎ¶¨ ÌõÑ Ï¶âÏãú Îç∞Ïù¥ÌÑ∞ ÏÉàÎ°úÍ≥†Ïπ® (WebSocket ÏÉÅÌÉúÎèÑ Î∞òÏòÅÎêòÎèÑÎ°ù)
        setTimeout(() => {
          loadNotifications();
        }, 100);
      }
      
      console.log(`üìä After marking as read - WebSocket unread count should be: 0`);
    } catch (error) {
      console.error('‚ùå Failed to mark unread notifications as read:', error);
    }
  };

  // Ïª¥Ìè¨ÎÑåÌä∏ ÎßàÏö¥Ìä∏ Ïãú Îç∞Ïù¥ÌÑ∞ Î°úÎìú
  useEffect(() => {
    loadNotifications();
  }, []);

  // Ïã§ÏãúÍ∞Ñ ÏïåÎ¶ºÏù¥ ÏóÖÎç∞Ïù¥Ìä∏Îê† ÎïåÎßàÎã§ Í∏∞Ï°¥ ÏïåÎ¶ºÍ≥º Î≥ëÌï©
  const mergedNotifications = useMemo(() => {
    // WebSocket Ïã§ÏãúÍ∞Ñ ÏïåÎ¶ºÏùÑ Î∞±ÏóîÎìú ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
    const convertedRealtimeNotifications = realtimeNotifications.map(wsNotification => ({
      id: wsNotification.id || Math.floor(Math.random() * 1000000), // ÏûÑÏãú ID
      userNm: wsNotification.userNm,
      type: wsNotification.type as NotificationType,
      title: wsNotification.title,
      message: wsNotification.message,
      relatedId: wsNotification.relatedId || null,
      isRead: wsNotification.isRead,
      actionRoute: wsNotification.actionRoute || null,
      createdAt: wsNotification.createdAt,
      updatedAt: wsNotification.updatedAt
    }));

    // Í∏∞Ï°¥ API ÏïåÎ¶ºÍ≥º Ïã§ÏãúÍ∞Ñ ÏïåÎ¶º Î≥ëÌï© (Ï§ëÎ≥µ Ï†úÍ±∞, API ÏïåÎ¶º Ïö∞ÏÑ†)
    const allNotifications = [...notifications, ...convertedRealtimeNotifications];
    const uniqueNotifications = allNotifications.filter((notification, index, self) => 
      index === self.findIndex(n => n.id === notification.id)
    );

    // ÏÉùÏÑ±Ïùº Í∏∞Ï§ÄÏúºÎ°ú ÎÇ¥Î¶ºÏ∞®Ïàú Ï†ïÎ†¨
    return uniqueNotifications.sort((a, b) => 
      new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    );
  }, [notifications, realtimeNotifications]);

  // Î≥ëÌï©Îêú Îç∞Ïù¥ÌÑ∞Î•º ÌîÑÎ°†Ìä∏ÏóîÎìú ÌòïÌÉúÎ°ú Î≥ÄÌôò
  const convertedNotifications = useMemo<NotificationItem[]>(() => {
    const result = mergedNotifications && Array.isArray(mergedNotifications) ? mergedNotifications.map(convertToNotificationItem) : [];
    console.log('üîÑ Converting merged notifications:', mergedNotifications?.length || 0, 'items');
    console.log('üîÑ Converted result:', result.length, 'items');
    console.log('üîå WebSocket connected:', isConnected, 'State:', connectionState);
    console.log('üìä Unread count:', unreadCount);
    if (result.length > 0) {
      console.log('üîÑ First converted item:', result[0]);
      console.log('üîÑ Read states:', result.map(item => ({ id: item.id, isRead: item.isRead, type: item.type })));
    }
    return result;
  }, [mergedNotifications, isConnected, connectionState, unreadCount]);

  // ÌÉ≠Î≥Ñ ÌïÑÌÑ∞ÎßÅÎêú ÏïåÎ¶º Îç∞Ïù¥ÌÑ∞
  const filteredNotifications = useMemo(() => {
    const filtered = convertedNotifications.filter(notification => {
      switch (activeTab) {
        case "Ïû•ÌïôÍ∏à":
          return notification.type === "scholarship";
        case "ÎßàÍ∞êÏûÑÎ∞ï":
          return notification.type === "deadline";
        case "ÎÇ¥ ÏùºÏ†ï":
          return notification.type === "schedule";
        default:
          return true;
      }
    });
    console.log(`üìã Filtered notifications for "${activeTab}":`, filtered.length, 'items');
    console.log(`üìã Filter details:`, filtered.map(item => ({ id: item.id, type: item.type, isRead: item.isRead })));
    return filtered;
  }, [convertedNotifications, activeTab]);

  if (loading) {
    return (
      <ImageBackground source={SOLSOLBackground} style={styles.bg} resizeMode="cover">
        <StatusBar barStyle="dark-content" />
        <View style={styles.centeredContainer}>
          <ActivityIndicator size="large" color="#6B86FF" />
        </View>
      </ImageBackground>
    );
  }

  return (
    <ImageBackground source={SOLSOLBackground} style={styles.bg} resizeMode="cover">
      <StatusBar barStyle="dark-content" />
      <ScrollView 
        style={styles.container}
        contentContainerStyle={styles.contentContainer}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} />
        }
        showsVerticalScrollIndicator={false}
      >
        {/* MainPageÏôÄ ÎèôÏùºÌïú Í≥†Ï†ï ÎÑàÎπÑ Ïª®ÌÖåÏù¥ÎÑà */}
        <View style={styles.phone}>
          <TopBar title="ÏïåÎ¶ºÌï®" />

          {/* ÏïåÎ¶º ÌÉ≠ */}
          <NotificationTabs
            tabs={["Ï†ÑÏ≤¥", "Ïû•ÌïôÍ∏à", "ÎßàÍ∞êÏûÑÎ∞ï", "ÎÇ¥ ÏùºÏ†ï"]}
            active={activeTab}
            onChange={setActiveTab}
          />

          {/* ÏïåÎ¶º Î¶¨Ïä§Ìä∏ */}
          <View style={styles.notificationList}>
            {filteredNotifications.length > 0 ? (
              filteredNotifications.map((notification) => (
                <NotificationCard 
                  key={notification.id} 
                  notification={notification} 
                  onMarkAsRead={handleMarkAsRead}
                  onSwipeDelete={handleSwipeDelete}
                  onDeleteForAction={handleDeleteNotificationForAction}
                />
              ))
            ) : (
              <View style={styles.emptyState}>
                <Text style={styles.emptyText}>
                  {activeTab === "Ï†ÑÏ≤¥"
                    ? "ÏïåÎ¶ºÏù¥ ÏóÜÏäµÎãàÎã§."
                    : `${activeTab} ÏïåÎ¶ºÏù¥ ÏóÜÏäµÎãàÎã§.`
                  }
                </Text>
              </View>
            )}
          </View>
        </View>
      </ScrollView>
    </ImageBackground>
  );
}

// MainPageÏôÄ ÎèôÏùºÌïú Í≥†Ï†ï ÎÑàÎπÑ ÏÑ§Ï†ï
const PHONE_WIDTH = 360;

const styles = StyleSheet.create({
  bg: { 
    flex: 1, 
    backgroundColor: "#F5F7FF" 
  },
  container: { 
    flex: 1, 
    backgroundColor: "transparent" 
  },
  contentContainer: {
    paddingBottom: 24,
    alignItems: "center", // Í∞ÄÏö¥Îç∞ Ï†ïÎ†¨ (ÏõπÏóêÏÑú Ï¢åÏö∞ Ïó¨Î∞± Î∞©ÏßÄ)
  },
  phone: {
    width: PHONE_WIDTH,
    paddingBottom: 16,
  },
  centeredContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  notificationList: { 
    paddingHorizontal: 12, 
    marginTop: 8 
  },
  emptyState: {
    padding: 40,
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: 20,
  },
  emptyText: {
    fontSize: 14,
    color: "#7C89A6",
    textAlign: 'center',
    fontWeight: '600',
  },
});