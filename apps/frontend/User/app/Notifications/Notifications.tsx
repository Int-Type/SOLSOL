import React, { useState, useEffect, useMemo } from "react";
import { ImageBackground, ScrollView, StatusBar, StyleSheet, View, ActivityIndicator, RefreshControl, Text } from "react-native";
import BG from "../../assets/images/SOLSOLBackground.png";
import { TopBar } from "../../components/scholarship/TopBar";
import { NotificationTabs } from "../../components/notifications/NotificationTabs";
import { NotificationCard, NotificationItem } from "../../components/notifications/NotificationCard";
import { notificationApi, Notification, NotificationType } from "../../services/notification.api";
import { useWebSocket } from "../../contexts/WebSocketContext";

export default function NotificationsPage() {
  const [activeTab, setActiveTab] = useState<string>("Ï†ÑÏ≤¥");
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  
  // WebSocket Ïª®ÌÖçÏä§Ìä∏ÏóêÏÑú Ïã§ÏãúÍ∞Ñ ÏïåÎ¶º Í∞ÄÏ†∏Ïò§Í∏∞
  const { 
    notifications: realtimeNotifications, 
    unreadCount, 
    isConnected, 
    connectionState, 
    markAsRead: markRealtimeAsRead,
    deleteNotification: deleteRealtimeNotification 
  } = useWebSocket();

  // Î∞±ÏóîÎìú ÏïåÎ¶º Îç∞Ïù¥ÌÑ∞Î•º ÌîÑÎ°†Ìä∏ÏóîÎìú ÌòïÌÉúÎ°ú Î≥ÄÌôò
  const convertToNotificationItem = (notification: Notification): NotificationItem => {
    const formatTimestamp = (createdAt: string) => {
      const now = new Date();
      const created = new Date(createdAt);
      const diffInHours = Math.floor((now.getTime() - created.getTime()) / (1000 * 60 * 60));
      
      if (diffInHours < 1) return "Î∞©Í∏à Ï†Ñ";
      if (diffInHours < 24) return `${diffInHours}ÏãúÍ∞Ñ Ï†Ñ`;
      
      const diffInDays = Math.floor(diffInHours / 24);
      if (diffInDays < 7) return `${diffInDays}Ïùº Ï†Ñ`;
      
      return `${Math.floor(diffInDays / 7)}Ï£ºÏùº Ï†Ñ`;
    };

    const getTypeAndRoute = (type: NotificationType) => {
      switch (type) {
        case NotificationType.NEW_SCHOLARSHIP:
          return { 
            displayType: "scholarship", 
            actionLabel: "Ïû•ÌïôÍ∏à Î≥¥Í∏∞", 
            actionRoute: "/Scholarship/ScholarshipDetail" 
          };
        case NotificationType.SCHOLARSHIP_RESULT:
          return { 
            displayType: "scholarship", 
            actionLabel: "Í≤∞Í≥º ÌôïÏù∏", 
            actionRoute: "/MyScholarship/MyScholarship" 
          };
        case NotificationType.MILEAGE_DEPOSIT:
          return { 
            displayType: "scholarship", 
            actionLabel: "ÎßàÏùºÎ¶¨ÏßÄ ÌôïÏù∏", 
            actionRoute: "/MyPage/MyPage" 
          };
        case NotificationType.ACCOUNT_TRANSFER:
          return { 
            displayType: "scholarship", 
            actionLabel: "Í≥ÑÏ¢å ÌôïÏù∏", 
            actionRoute: "/MyPage/MyPage" 
          };
        case NotificationType.SCHEDULE:
          return { 
            displayType: "schedule", 
            actionLabel: "ÏùºÏ†ï ÌôïÏù∏", 
            actionRoute: "/Schedule/MyCalendar" 
          };
        case NotificationType.DEADLINE_REMINDER:
          return { 
            displayType: "deadline", 
            actionLabel: "Ïû•ÌïôÍ∏à Î≥¥Í∏∞", 
            actionRoute: "/Scholarship/ScholarshipDetail" 
          };
        default:
          return { 
            displayType: "scholarship", 
            actionLabel: "ÌôïÏù∏ÌïòÍ∏∞", 
            actionRoute: "/" 
          };
      }
    };

    const typeInfo = getTypeAndRoute(notification.type);

    return {
      id: notification.id.toString(),
      type: typeInfo.displayType,
      title: notification.title,
      message: notification.message,
      timestamp: formatTimestamp(notification.createdAt),
      isRead: notification.isRead,
      actionLabel: typeInfo.actionLabel,
      actionRoute: notification.actionRoute || typeInfo.actionRoute
    };
  };

  // Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ìï®Ïàò
  const loadNotifications = async () => {
    try {
      setLoading(true);
      const data = await notificationApi.getUserNotifications();
      console.log('üéØ Received notifications data:', data);
      console.log('üéØ Data is array:', Array.isArray(data));
      console.log('üéØ Data length:', data?.length || 0);
      setNotifications(Array.isArray(data) ? data : []);
    } catch (error) {
      console.error('ÏïåÎ¶º Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®:', error);
      setNotifications([]);
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  // ÏÉàÎ°úÍ≥†Ïπ® Ìï®Ïàò
  const handleRefresh = () => {
    setRefreshing(true);
    loadNotifications();
  };

  // ÏïåÎ¶º ÏùΩÏùå Ï≤òÎ¶¨ Ìï®Ïàò (ÏùΩÏùå ÏÉÅÌÉúÎßå Î≥ÄÍ≤Ω, ÏÇ≠Ï†úÌïòÏßÄ ÏïäÏùå)
  const handleMarkAsRead = async (notificationId: string) => {
    try {
      const id = parseInt(notificationId);
      console.log(`üìñ Starting to mark notification as read: ${id}`);
      
      // Î∞±ÏóîÎìúÏóê ÏùΩÏùå Ï≤òÎ¶¨ ÏöîÏ≤≠
      await notificationApi.markAsRead(id);
      console.log(`‚úÖ Backend markAsRead successful for: ${id}`);
      
      // WebSocket Ïª®ÌÖçÏä§Ìä∏ÏóêÏÑúÎèÑ ÏùΩÏùå Ï≤òÎ¶¨
      markRealtimeAsRead(id);
      console.log(`‚úÖ WebSocket markAsRead successful for: ${id}`);
      
      // Î°úÏª¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ - ÏùΩÏùå ÏÉÅÌÉúÎßå Î≥ÄÍ≤Ω (ÏÇ≠Ï†úÌïòÏßÄ ÏïäÏùå)
      setNotifications(prev => {
        const updated = prev.map(notification => 
          notification.id === id
            ? { ...notification, isRead: true }
            : notification
        );
        console.log(`üìù Local state updated for: ${id}`, 
          updated.find(n => n.id === id)?.isRead ? 'READ' : 'UNREAD');
        return updated;
      });
    } catch (error) {
      console.error('ÏïåÎ¶º ÏùΩÏùå Ï≤òÎ¶¨ Ïã§Ìå®:', error);
    }
  };

  // Ïû•ÌïôÍ∏à Î≥¥Í∏∞Î•º ÏúÑÌïú ÏïåÎ¶º ÏÇ≠Ï†ú Ìï®Ïàò (Ïû•ÌïôÍ∏à Í¥ÄÎ†® ÏïåÎ¶ºÎßå)
  const handleDeleteNotificationForAction = async (notificationId: string, actionRoute: string) => {
    try {
      const id = parseInt(notificationId);
      console.log(`üóëÔ∏è Starting to delete notification for action: ${id}`);
      
      // Ïû•ÌïôÍ∏à Í¥ÄÎ†® ÏïåÎ¶ºÏù∏ Í≤ΩÏö∞ÏóêÎßå ÏÇ≠Ï†ú Ï≤òÎ¶¨
      if (actionRoute.includes('/Scholarship/ScholarshipDetail')) {
        // Î®ºÏ†Ä ÏùΩÏßÄ ÏïäÏùÄ ÏïåÎ¶ºÏù¥Î©¥ ÏùΩÏùå Ï≤òÎ¶¨ (unreadCount Í∞êÏÜå)
        const notification = notifications.find(n => n.id === id);
        if (notification && !notification.isRead) {
          await notificationApi.markAsRead(id);
          markRealtimeAsRead(id);
          console.log(`‚úÖ Marked notification ${id} as read before deletion`);
        }
        
        // Î∞±ÏóîÎìúÏóêÏÑú ÏïåÎ¶º ÏÇ≠Ï†ú
        await notificationApi.deleteNotification(id);
        console.log(`‚úÖ Backend deleteNotification successful for: ${id}`);
        
        // WebSocket Ïª®ÌÖçÏä§Ìä∏ÏóêÏÑúÎèÑ ÏÇ≠Ï†ú Ï≤òÎ¶¨
        deleteRealtimeNotification(id);
        console.log(`‚úÖ WebSocket deleteNotification successful for: ${id}`);
        
        // Î°úÏª¨ ÏÉÅÌÉúÏóêÏÑú Ï†úÍ±∞
        setNotifications(prev => {
          const updated = prev.filter(notification => notification.id !== id);
          console.log(`üìù Local state updated - removed notification ${id}, remaining: ${updated.length}`);
          return updated;
        });
      } else {
        // Îã§Î•∏ ÌÉÄÏûÖÏùò ÏïåÎ¶ºÏùÄ ÏùΩÏùå Ï≤òÎ¶¨Îßå
        await handleMarkAsRead(notificationId);
      }
    } catch (error) {
      console.error('ÏïåÎ¶º ÏÇ≠Ï†ú Ï≤òÎ¶¨ Ïã§Ìå®:', error);
    }
  };

  // ÏùΩÏßÄ ÏïäÏùÄ Î™®Îì† ÏïåÎ¶ºÏùÑ ÏùΩÏùå Ï≤òÎ¶¨ÌïòÎäî Ìï®Ïàò
  const markAllUnreadAsRead = async () => {
    try {
      console.log('üìñ Marking all unread notifications as read on page entry');
      
      // ÌòÑÏû¨ Î°úÎìúÎêú ÏïåÎ¶ºÏóêÏÑú ÏùΩÏßÄ ÏïäÏùÄ Í≤ÉÎì§ Ï∞æÍ∏∞
      const unreadNotifications = notifications.filter(n => !n.isRead);
      console.log(`üìñ Found ${unreadNotifications.length} unread notifications to mark as read`);
      
      // WebSocket Ïã§ÏãúÍ∞Ñ ÏïåÎ¶ºÏóêÏÑú ÏùΩÏßÄ ÏïäÏùÄ Í≤ÉÎì§ÎèÑ Ï∞æÍ∏∞
      const unreadRealtimeNotifications = realtimeNotifications.filter(n => !n.isRead);
      console.log(`üìñ Found ${unreadRealtimeNotifications.length} unread realtime notifications to mark as read`);
      
      // Í∞ÅÍ∞ÅÏùò ÏùΩÏßÄ ÏïäÏùÄ ÏïåÎ¶ºÏùÑ ÏùΩÏùå Ï≤òÎ¶¨ (API ÏïåÎ¶º)
      for (const notification of unreadNotifications) {
        try {
          await notificationApi.markAsRead(notification.id);
          markRealtimeAsRead(notification.id);
          console.log(`‚úÖ Marked notification ${notification.id} as read on page entry`);
        } catch (error) {
          console.warn(`‚ö†Ô∏è Failed to mark notification ${notification.id} as read:`, error);
        }
      }
      
      // WebSocket Ïã§ÏãúÍ∞Ñ ÏïåÎ¶ºÎì§ÎèÑ ÏùΩÏùå Ï≤òÎ¶¨
      for (const notification of unreadRealtimeNotifications) {
        try {
          markRealtimeAsRead(notification.id!);
          console.log(`‚úÖ Marked realtime notification ${notification.id} as read on page entry`);
        } catch (error) {
          console.warn(`‚ö†Ô∏è Failed to mark realtime notification ${notification.id} as read:`, error);
        }
      }
      
      // Î°úÏª¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
      if (unreadNotifications.length > 0 || unreadRealtimeNotifications.length > 0) {
        setNotifications(prev => 
          prev.map(notification => ({ ...notification, isRead: true }))
        );
        
        // ÏùΩÏùå Ï≤òÎ¶¨ ÌõÑ Ï¶âÏãú Îç∞Ïù¥ÌÑ∞ ÏÉàÎ°úÍ≥†Ïπ® (WebSocket ÏÉÅÌÉúÎèÑ Î∞òÏòÅÎêòÎèÑÎ°ù)
        setTimeout(() => {
          loadNotifications();
        }, 100);
      }
      
      console.log(`üìä After marking as read - WebSocket unread count should be: 0`);
    } catch (error) {
      console.error('‚ùå Failed to mark unread notifications as read:', error);
    }
  };

  // Ïª¥Ìè¨ÎÑåÌä∏ ÎßàÏö¥Ìä∏ Ïãú Îç∞Ïù¥ÌÑ∞ Î°úÎìú Î∞è ÏùΩÏßÄ ÏïäÏùÄ ÏïåÎ¶º ÏùΩÏùå Ï≤òÎ¶¨
  useEffect(() => {
    const initializePage = async () => {
      await loadNotifications();
      // ÏïåÎ¶º Îç∞Ïù¥ÌÑ∞Î•º Î°úÎìúÌïú ÌõÑ ÏùΩÏßÄ ÏïäÏùÄ ÏïåÎ¶ºÎì§ÏùÑ ÏùΩÏùå Ï≤òÎ¶¨
      await markAllUnreadAsRead();
    };
    
    initializePage();
  }, []);

  // Ïã§ÏãúÍ∞Ñ ÏïåÎ¶ºÏù¥ ÏóÖÎç∞Ïù¥Ìä∏Îê† ÎïåÎßàÎã§ Í∏∞Ï°¥ ÏïåÎ¶ºÍ≥º Î≥ëÌï©
  const mergedNotifications = useMemo(() => {
    // WebSocket Ïã§ÏãúÍ∞Ñ ÏïåÎ¶ºÏùÑ Î∞±ÏóîÎìú ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
    const convertedRealtimeNotifications = realtimeNotifications.map(wsNotification => ({
      id: wsNotification.id || Math.floor(Math.random() * 1000000), // ÏûÑÏãú ID
      userNm: wsNotification.userNm,
      type: wsNotification.type as NotificationType,
      title: wsNotification.title,
      message: wsNotification.message,
      relatedId: wsNotification.relatedId || null,
      isRead: wsNotification.isRead,
      actionRoute: wsNotification.actionRoute || null,
      createdAt: wsNotification.createdAt,
      updatedAt: wsNotification.updatedAt
    }));

    // Í∏∞Ï°¥ API ÏïåÎ¶ºÍ≥º Ïã§ÏãúÍ∞Ñ ÏïåÎ¶º Î≥ëÌï© (Ï§ëÎ≥µ Ï†úÍ±∞, API ÏïåÎ¶º Ïö∞ÏÑ†)
    const allNotifications = [...notifications, ...convertedRealtimeNotifications];
    const uniqueNotifications = allNotifications.filter((notification, index, self) => 
      index === self.findIndex(n => n.id === notification.id)
    );

    // ÏÉùÏÑ±Ïùº Í∏∞Ï§ÄÏúºÎ°ú ÎÇ¥Î¶ºÏ∞®Ïàú Ï†ïÎ†¨
    return uniqueNotifications.sort((a, b) => 
      new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    );
  }, [notifications, realtimeNotifications]);

  // Î≥ëÌï©Îêú Îç∞Ïù¥ÌÑ∞Î•º ÌîÑÎ°†Ìä∏ÏóîÎìú ÌòïÌÉúÎ°ú Î≥ÄÌôò
  const convertedNotifications = useMemo<NotificationItem[]>(() => {
    const result = mergedNotifications && Array.isArray(mergedNotifications) ? mergedNotifications.map(convertToNotificationItem) : [];
    console.log('üîÑ Converting merged notifications:', mergedNotifications?.length || 0, 'items');
    console.log('üîÑ Converted result:', result.length, 'items');
    console.log('üîå WebSocket connected:', isConnected, 'State:', connectionState);
    console.log('üìä Unread count:', unreadCount);
    if (result.length > 0) {
      console.log('üîÑ First converted item:', result[0]);
      console.log('üîÑ Read states:', result.map(item => ({ id: item.id, isRead: item.isRead, type: item.type })));
    }
    return result;
  }, [mergedNotifications, isConnected, connectionState, unreadCount]);

  // ÌÉ≠Î≥Ñ ÌïÑÌÑ∞ÎßÅÎêú ÏïåÎ¶º Îç∞Ïù¥ÌÑ∞
  const filteredNotifications = useMemo(() => {
    const filtered = convertedNotifications.filter(notification => {
      switch (activeTab) {
        case "Ïû•ÌïôÍ∏à":
          return notification.type === "scholarship";
        case "ÎßàÍ∞êÏûÑÎ∞ï":
          return notification.type === "deadline";
        case "ÎÇ¥ ÏùºÏ†ï":
          return notification.type === "schedule";
        default:
          return true;
      }
    });
    console.log(`üìã Filtered notifications for "${activeTab}":`, filtered.length, 'items');
    console.log(`üìã Filter details:`, filtered.map(item => ({ id: item.id, type: item.type, isRead: item.isRead })));
    return filtered;
  }, [convertedNotifications, activeTab]);

  if (loading) {
    return (
      <ImageBackground source={BG} style={{ flex: 1 }} resizeMode="cover">
        <StatusBar barStyle="dark-content" />
        <View style={[styles.phone, { justifyContent: 'center', alignItems: 'center', flex: 1 }]}>
          <ActivityIndicator size="large" color="#6B86FF" />
        </View>
      </ImageBackground>
    );
  }

  return (
    <ImageBackground source={BG} style={{ flex: 1 }} resizeMode="cover">
      <StatusBar barStyle="dark-content" />
      <ScrollView 
        contentContainerStyle={{ alignItems: "center", paddingBottom: 24 }}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} />
        }
      >
        <View style={styles.phone}>
          <TopBar title="ÏïåÎ¶ºÌï®" />

          {/* ÏïåÎ¶º ÌÉ≠ */}
          <NotificationTabs
            tabs={["Ï†ÑÏ≤¥", "Ïû•ÌïôÍ∏à", "ÎßàÍ∞êÏûÑÎ∞ï", "ÎÇ¥ ÏùºÏ†ï"]}
            active={activeTab}
            onChange={setActiveTab}
          />

          {/* ÏïåÎ¶º Î¶¨Ïä§Ìä∏ */}
          <View style={styles.notificationList}>
            {filteredNotifications.length > 0 ? (
              filteredNotifications.map((notification) => (
                <NotificationCard 
                  key={notification.id} 
                  notification={notification} 
                  onMarkAsRead={handleMarkAsRead}
                  onDeleteForAction={handleDeleteNotificationForAction}
                />
              ))
            ) : (
              <View style={styles.emptyState}>
                <Text style={styles.emptyText}>
                  {activeTab === "Ï†ÑÏ≤¥"
                    ? "ÏïåÎ¶ºÏù¥ ÏóÜÏäµÎãàÎã§."
                    : `${activeTab} ÏïåÎ¶ºÏù¥ ÏóÜÏäµÎãàÎã§.`
                  }
                </Text>
              </View>
            )}
          </View>
        </View>
      </ScrollView>
    </ImageBackground>
  );
}

const styles = StyleSheet.create({
  phone: { width: 360, paddingVertical: 8 },
  notificationList: { paddingHorizontal: 12, marginTop: 8 },
  emptyState: {
    padding: 40,
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: 20,
  },
  emptyText: {
    fontSize: 14,
    color: "#7C89A6",
    textAlign: 'center',
    fontWeight: '600',
  },
});